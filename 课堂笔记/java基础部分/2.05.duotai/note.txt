多态：
	对同一种事物，有不同种的表现形态
		重载和重写
	
	父类的引用，指向子类的对象
		new 子类()
	
	
Object类是所有类的父类
	在Object类中的equals()方法和==没有任何的区别，也可以判断内存地址
	但String类重写的equals()方法，把判断内存地址丢了，所以我们用的equals方法不能判断内存地址
	
	 	{ 因为子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特，
	    定义一个父类类型的引用指向一个子类的对象既可以使用子类强大的功能，又可以抽取父类的共性。 
		所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，它是无可奈何的；
		同时，父类中的一个方法只有在父类中定义而在子类中没有重写的情况下，才可以被父类类型的引用调用；
		对于父类中定义的方法，如果子类中重写了该方法，那么父类类型的引用将会调用子类中的这个方法，这就是动态连接。
		也可以叫做动态绑定。}
		
instanceof：
	A instanceof B: 判断A是不是B类型的，如果是返回true，不是返回false	

	
抽象方法：
	没有方法体即没有{}的方法，叫抽象方法，用关键字 abstract 修饰
	抽象方法一定要放在抽象类中
	子类继承有抽象方法的父类，那么就一定要重写这个抽象方法
	
向上转型：自动类型转换，小的转大的
向下转型：强制类型转换，大的转小的
	
Pet pet = new Dog();
pet.show();	
	父类的引用指向子类的对象时，调用方法，调用的是子类里的方法
	如果想调用父类里的方法
		1.new 父类()	   Pet pet = new Pet();
		2.子类不重写父类方法
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	